<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="wysec">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>我的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">我的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/19/HTTPS%E8%AF%A6%E8%A7%A3%EF%BC%9APKI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wysec">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/19/HTTPS%E8%AF%A6%E8%A7%A3%EF%BC%9APKI/" class="post-title-link" itemprop="url">HTTPS详解：PKI</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-19 13:30:46 / 修改时间：13:34:19" itemprop="dateCreated datePublished" datetime="2020-04-19T13:30:46+08:00">2020-04-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS）是一种网络安全传输协议。在计算机网络上，HTTPS经由HTTP（超文本传输协议）进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网络服务器的身份认证，保护交换数据的隐私与完整性。</p>
<p>要使一网络服务器接受HTTPS连接，必须创建数字证书并交由证书颁发机构（CA）签名以使浏览器接受。证书颁发机构会验证数字证书持有人和其声明的为同一人。浏览器通常都预装了证书颁发机构的证书，所以他们可以验证该签名。</p>
<h2 id="PKI系统"><a href="#PKI系统" class="headerlink" title="PKI系统"></a>PKI系统</h2><p>公开密钥基础设施（Public Key Infrastructure，缩写：PKI），是一组由硬件、软件、参与者、管理政策与流程组成的基础架构，其目的在于创造、管理、分配、使用、存储以及撤销数字证书。</p>
<p>由于使用传统的公钥系统只能保证数据的保密性，不能提供完整性和抗抵赖的安全保护。这就导致接收者不能确保其收到的信息是否被篡改过，或在发送者否认是其发送的，这些都存在很大的安全风险。对于这些问题就可以使用PKI来解决。</p>
<h3 id="PKI组成"><a href="#PKI组成" class="headerlink" title="PKI组成"></a>PKI组成</h3><p>完整的PKI系统定有如下五个基本部分：认证机构(CA)、数字证书库、密钥备份及恢复系统、证书作废系统、应用接口（API）。</p>
<ol>
<li><u>认证机构(CA)</u>：数字证书的申请及签发机构，CA必须具备权威性的特征。CA的具有的功能有。</li>
</ol>
<ul>
<li>接收验证最终用户数字证书的申请</li>
<li>确定是否接受最终用户数字证书的申请-证书的审批</li>
<li>向申请者颁发、拒绝颁发数字证书-证书的发放</li>
<li>接收、处理最终用户的数字证书更新请求，证书的更新</li>
<li>接收最终用户数字证书的查询、撤销</li>
<li>产生和发布证书废止列表(CRL)</li>
<li>数字证书的归档</li>
<li>密钥归档</li>
<li>历史数据归档</li>
</ul>
<ol start="2">
<li>数字证书库：用于存储已签发的数字证书及公钥，用户可由此获得所需的其他用户的证书及公钥。</li>
<li>密钥备份及恢复系统：PKI提供备份与恢复密钥的机制。注意：密钥的备份与恢复必须由可信的机构来完成。并且密钥备份与恢复只能针对解密密钥，签名私钥为确保其唯一性而不能够备份。</li>
<li>证书作废系统：证书作废处理系统是PKI的一个必备的组件。</li>
<li>应用接口（API）：PKI的价值在于使用户能够方便地使用加密、数字签名等安全服务，因此一个完整的PKI必须提供良好的应用接口系统，使得各种各样的应用能够以安全、一致、可信的方式与PKI交互，确保安全网络环境的完整性和易用性。</li>
</ol>
<h2 id="数字证书结构"><a href="#数字证书结构" class="headerlink" title="数字证书结构"></a>数字证书结构</h2><p>CA使用X.509标准的数字证书。X.509证书是一些标准字段的集合，这些字段包含有关用户或设备及其相应公钥的信息。所有的X.509证书包含以下数据。</p>
<ul>
<li>版本号：指出该证书使用了哪种版本的X.509标准（版本1、2或3），版本号会影响证书中的一些特定信息，目前的版本为3</li>
<li>序列号： 标识证书的唯一整数，由证书颁发者分配的本证书的唯一标识符</li>
<li>签名算法标识符： 用于签证书的算法标识，由对象标识符加上相关的参数组成，用于说明本证书所用的数字签名算法。例如，SHA-1和RSA的对象标识符就用来说明该数字签名是利用RSA对SHA-1杂凑加密</li>
<li>认证机构的数字签名：这是使用发布者私钥生成的签名，以确保这个证书在发放之后没有被撰改过</li>
<li>认证机构： 证书颁发者的可识别名（DN），是签发该证书的实体唯一的CA的X.500名字。使用该证书意味着信任签发证书的实体。(注意：在某些情况下，比如根或顶级CA证书，发布者自己签发证书)</li>
<li>有效期限： 证书起始日期和时间以及终止日期和时间；指明证书在这两个时间内有效</li>
<li>主题信息：证书持有人唯一的标识符(或称DN-distinguished name)这个名字在 Internet上应该是唯一的</li>
<li>公钥信息： 包括证书持有人的公钥、算法(指明密钥属于哪种密码系统)的标识符和其他相关的密钥参数</li>
<li>颁发者唯一标识符：标识符—证书颁发者的唯一标识符，仅在版本2和版本3中有要求，属于可选项</li>
</ul>
<p>在2以上版本的X.509证书增加了扩展部分，包括的字段有：</p>
<ul>
<li>发行者密钥标识符：证书所含密钥的唯一标识符，用来区分同一证书拥有者的多对密钥。</li>
<li>密钥使用：一个比特串，指明（限定）证书的公钥可以完成的功能或服务，如：证书签名、数据加密等。如果某一证书将 KeyUsage 扩展标记为“极重要”，而且设置为“keyCertSign”，则在 SSL 通信期间该证书出现时将被拒绝，因为该证书扩展表示相关私钥应只用于签写证书，而不应该用于 SSL。</li>
<li>CRL分布点：指明CRL的分布地点</li>
<li>私钥的使用期：指明证书中与公钥相联系的私钥的使用期限，它也有Not Before和Not After组成。若此项不存在时，公私钥的使用期是一样的。</li>
<li>证书策略：由对象标识符和限定符组成，这些对象标识符说明证书的颁发和使用策略有关。</li>
<li>策略映射：表明两个CA域之间的一个或多个策略对象标识符的等价关系，仅在CA证书里存在</li>
<li>主体别名：指出证书拥有者的别名，如电子邮件地址、IP地址等，别名是和DN绑定在一起的。</li>
<li>颁发者别名：指出证书颁发者的别名，如电子邮件地址、IP地址等，但颁发者的DN必须出现在证书的颁发者字段。</li>
<li>主体目录属性：指出证书拥有者的一系列属性。可以使用这一项来传递访问控制信息。</li>
</ul>
<p>这是百度的数字证书示例：<br><img src="http://www.enkichen.com/uploads/baidudigitalcertificate.png" alt="数字证书"></p>
<h2 id="数字证书格式"><a href="#数字证书格式" class="headerlink" title="数字证书格式"></a>数字证书格式</h2><p>数字证书体现为一个或一系列相关经过加密的数据文件。常见格式有：</p>
<ul>
<li>符合PKI ITU-T X509标准，传统标准（.DER .PEM .CER .CRT）</li>
<li>符合PKCS#7 加密消息语法标准（.P7B .P7C .SPC .P7R）</li>
<li>符合PKCS#10 证书请求标准（.p10）</li>
<li>符合PKCS#12 个人信息交换标准（.pfx *.p12）</li>
</ul>
<p>以上只是常用的几种标准，其中X509证书还分两种编码形式：</p>
<ul>
<li>X.509 DER(Distinguished Encoding Rules)编码，后缀为：.DER .CER .CRT</li>
<li>X.509 BASE64编码，后缀为：.PEM .CER .CRT</li>
</ul>
<p>X509是数字证书的基本规范，而P7和P12则是两个实现规范，P7用于数字信封，P12则是带有私钥的证书实现规范。采用的标准不同，生成的数字证书，包含内容也可能不同。下面就证书包含/可能包含的内容做个汇总，一般证书特性有：</p>
<ul>
<li>存储格式：二进制还是ASCII</li>
<li>是否包含公钥、私钥</li>
<li>包含一个还是多个证书</li>
<li>是否支持密码保护（针对当前证书）</li>
</ul>
<p>其中：</p>
<ul>
<li>DER、CER、CRT以二进制形式存放证书，只有公钥，不包含私钥   //也可能包括私钥！</li>
<li>CSR证书请求</li>
<li>PEM（Privacy Enhanced Mail）以Base64编码形式存放证书，以”—–BEGIN CERTIFICATE—–” 和 “—–END CERTIFICATE—–”封装，只有公钥</li>
<li>PFX、P12也是以二进制形式存放证书，包含公钥、私钥，包含保护密码。PFX和P12存储格式完全相同只是扩展名不同</li>
<li>P10证书请求</li>
<li>P7R是CA对证书请求回复，一般做数字信封</li>
<li>P7B/P7C证书链，Base64的格式存储，有类似BEGIN PKCS7—–” 和 “—–END PKCS7—–”的头尾标记，可包含一个或多个证书（证书链），不能存储私钥</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.enkichen.com/2016/04/12/certification-and-pki/" target="_blank" rel="noopener">http://www.enkichen.com/2016/04/12/certification-and-pki/</a></p>
<p><a href="https://fatfatson.github.io/2018/07/27/openssl%E8%B5%B0%E4%B8%80%E8%BD%AECA%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%8F%91%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E5%90%84%E4%B8%AA%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8/" target="_blank" rel="noopener">https://fatfatson.github.io/2018/07/27/openssl%E8%B5%B0%E4%B8%80%E8%BD%AECA%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%8F%91%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E5%90%84%E4%B8%AA%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/11/OpenID%20Connect%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wysec">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/11/OpenID%20Connect%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">OpenID Connect基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-11 15:14:35 / 修改时间：15:22:06" itemprop="dateCreated datePublished" datetime="2020-04-11T15:14:35+08:00">2020-04-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OpenID Connect（OIDC）是一种基于OAuth 2.0授权框架的身份认证协议。它是OpenID的第三代技术。它支持对多种客户端（Web、移动、JS等）的认证。</p>
<blockquote>
<p>OpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol. It allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner.</p>
<p>OpenID Connect allows clients of all types, including Web-based, mobile, and JavaScript clients, to request and receive information about authenticated sessions and end-users. The specification suite is extensible, allowing participants to use optional features such as encryption of identity data, discovery of OpenID Providers, and session management, when it makes sense for them.</p>
</blockquote>
<p>OIDC协议规范体系如下：</p>
<p><img src="http://openid.net/wordpress-content/uploads/2014/02/OpenIDConnect-Map-4Feb2014.png" alt=""></p>
<h2 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h2><ul>
<li><p><strong>EU</strong>：End User/最终用户，要向网站表明身份的人。</p>
</li>
<li><p><strong>RP</strong>：Relying Party/依赖方 ，用来代指OAuth2中的受信任的客户端，身份认证和授权信息的消费方；要对最终用户身份进行认证的网站。</p>
</li>
<li><p><strong>OP</strong>：OpenID Provider/身份提供者，有能力提供EU身份认证的服务方（比如OAuth2中的授权服务），用来为RP提供EU的身份认证信息。</p>
</li>
<li><p><strong>ID Token</strong>：JWT格式的数据，包含EU身份认证的信息。</p>
</li>
<li><p><strong>UserInfo Endpoint</strong>：用户信息接口（受OAuth2保护），当RP使用ID Token访问时，返回授权用户的信息，此接口必须使用HTTPS。</p>
</li>
</ul>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>可以将OIDC的流程抽象成以下5个步骤：</p>
<ol>
<li>RP（client）发送一个认证请求给OP（OpenID Provider）；</li>
<li>OP对EU（End-User）进行身份认证，然后提供授权；</li>
<li>OP把<code>ID Token</code>和<code>Access Token</code>（需要的话）返回给RP；</li>
<li>RP使用Access Token发送一个请求UserInfo EndPoint；</li>
<li>UserInfo EndPoint返回EU的Claims。</li>
</ol>
<p>这些步骤如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+--------+                                   +--------+</span><br><span class="line">|        |                                   |        |</span><br><span class="line">|        |---------(1) AuthN Request--------&gt;|        |</span><br><span class="line">|        |                                   |        |</span><br><span class="line">|        |  +--------+                       |        |</span><br><span class="line">|        |  |        |                       |        |</span><br><span class="line">|        |  |  End-  |&lt;--(2) AuthN &amp; AuthZ--&gt;|        |</span><br><span class="line">|        |  |  User  |                       |        |</span><br><span class="line">|   RP   |  |        |                       |   OP   |</span><br><span class="line">|        |  +--------+                       |        |</span><br><span class="line">|        |                                   |        |</span><br><span class="line">|        |&lt;--------(3) AuthN Response--------|        |</span><br><span class="line">|        |                                   |        |</span><br><span class="line">|        |---------(4) UserInfo Request-----&gt;|        |</span><br><span class="line">|        |                                   |        |</span><br><span class="line">|        |&lt;--------(5) UserInfo Response-----|        |</span><br><span class="line">|        |                                   |        |</span><br><span class="line">+--------+                                   +--------+</span><br></pre></td></tr></table></figure>
<p>备注：<em>AuthN=Authentication，表示认证；AuthZ=Authorization，表示授权。</em></p>
<h2 id="ID-Token"><a href="#ID-Token" class="headerlink" title="ID Token"></a>ID Token</h2><p>OIDC对OAuth2最主要的扩展就是提供了ID Token。ID Token是一个安全令牌，是一个授权服务器提供的包含用户信息（由一组Cliams构成以及其他辅助的Cliams）的JWT格式的数据结构。ID Token的主要构成部分如下：</p>
<ul>
<li><strong>iss</strong> = Issuer Identifier：必须。提供认证信息者的唯一标识。一般是一个https的url（不包含querystring和fragment部分）。</li>
<li><strong>sub</strong> = Subject Identifier：必须。iss提供的EU的标识，在iss范围内唯一。它会被RP用来标识唯一的用户。最长为255个ASCII个字符。</li>
<li><strong>aud</strong> = Audience(s)：必须。标识ID Token的受众。必须包含OAuth2的client_id。</li>
<li><strong>exp</strong> = Expiration time：必须。过期时间，超过此时间的ID Token会作废不再被验证通过。</li>
<li><strong>iat</strong> = Issued At Time：必须。JWT的构建的时间。</li>
<li><strong>auth_time</strong> = AuthenticationTime：EU完成认证的时间。如果RP发送AuthN请求的时候携带max_age的参数，则此Claim是必须的。</li>
<li><strong>nonce</strong>：RP发送请求的时候提供的随机字符串，用来减缓重放攻击，也可以来关联ID Token和RP本身的Session信息。</li>
<li><strong>acr</strong> = Authentication Context Class Reference：可选。表示一个认证上下文引用值，可以用来标识认证上下文类。</li>
<li><strong>amr</strong> = Authentication Methods References：可选。表示一组认证方法。</li>
<li><strong>azp</strong> = Authorized party：可选。结合aud使用。只有在被认证的一方和受众（aud）不一致时才使用此值，一般情况下很少使用。</li>
</ul>
<p>ID Token通常情况下还会包含其他的Claims（毕竟上述claim中只有sub是和EU相关的，这在一般情况下是不够的，必须还需要EU的用户名，头像等其他的资料，OIDC提供了一组公共的cliams，可参考<a href="http://openid.net/specs/openid-connect-core-1_0.html#StandardClaims" target="_blank" rel="noopener">here</a>。</p>
<p>另外ID Token必须使用<code>JWS</code>进行签名和<code>JWE</code>加密，从而提供认证的完整性、不可否认性以及可选的保密性。</p>
<p>一个ID Token的例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;iss&quot;: &quot;https:&#x2F;&#x2F;server.example.com&quot;,</span><br><span class="line"> &quot;sub&quot;: &quot;24400320&quot;,</span><br><span class="line"> &quot;aud&quot;: &quot;s6BhdRkqt3&quot;,</span><br><span class="line"> &quot;nonce&quot;: &quot;n-0S6_WzA2Mj&quot;,</span><br><span class="line"> &quot;exp&quot;: 1311281970,</span><br><span class="line"> &quot;iat&quot;: 1311280970,</span><br><span class="line"> &quot;auth_time&quot;: 1311280969,</span><br><span class="line"> &quot;acr&quot;: &quot;urn:mace:incommon:iap:silver&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>因为OIDC基于OAuth2，所以OIDC的认证流程主要是由OAuth2的几种授权流程延伸而来的，有以下3种：</p>
<ul>
<li>Authorization Code Flow：使用OAuth2的授权码来换取Id Token和Access Token。</li>
<li>Implicit Flow：使用OAuth2的Implicit流程获取Id Token和Access Token。</li>
<li>Hybrid Flow：混合Authorization Code Flow + Implici Flow。</li>
</ul>
<h3 id="授权码模式流认证"><a href="#授权码模式流认证" class="headerlink" title="授权码模式流认证"></a>授权码模式流认证</h3><p>使用授权码模式流（Authorization Code Flow）来进行认证时，所有的token都由OP的Token Endpoint来发放。</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>Client准备包含所需请求参数的Authentication Request。</li>
<li>Client发送request到Authorization Server。</li>
<li>Authorization Server认证End-User。</li>
<li>Authorization Server获得EU的同意/授权。</li>
<li>Authorization Server sends the End-User back to the Client with an Authorization Code.</li>
<li>Client使用Authorization Code到Token Endpoint请求响应。</li>
<li>Client接收包含ID Token和Access Token的响应（response body）。</li>
<li>Client验证ID Token并检索用户的End-User’s Subject Identifier。</li>
</ol>
<h4 id="Authorization-Endpoint"><a href="#Authorization-Endpoint" class="headerlink" title="Authorization Endpoint"></a>Authorization Endpoint</h4><p>The Authorization Endpoint performs Authentication of the End-User. This is done by sending the User Agent to the Authorization Server’s Authorization Endpoint for Authentication and Authorization, using request parameters defined by OAuth 2.0 and additional parameters and parameter values defined by OpenID Connect.</p>
<h5 id="1-Authentication-Request"><a href="#1-Authentication-Request" class="headerlink" title="1. Authentication Request"></a>1. Authentication Request</h5><p>Authentication Request需要提供如下的参数：</p>
<ul>
<li>scope：必须。OIDC的请求必须包含值为“openid”的scope的参数。</li>
<li>response_type：必选。同OAuth2。</li>
<li>client_id：必选。同OAuth2。</li>
<li>redirect_uri：必选。同OAuth2。</li>
<li>state：推荐。同OAuth2。防止CSRF, XSRF。</li>
</ul>
<p>请求示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;authorize?</span><br><span class="line">  response_type&#x3D;code</span><br><span class="line">  &amp;scope&#x3D;openid%20profile%20email</span><br><span class="line">  &amp;client_id&#x3D;s6BhdRkqt3</span><br><span class="line">  &amp;state&#x3D;af0ifjsldkj</span><br><span class="line">  &amp;redirect_uri&#x3D;https%3A%2F%2Fclient.example.org%2Fcb HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure>

<h5 id="5-Successful-Authentication-Response"><a href="#5-Successful-Authentication-Response" class="headerlink" title="5. Successful Authentication Response"></a>5. Successful Authentication Response</h5><p>最后会重定向到RP指定的回调地址(redirect_uri)，并且把code和state参数传递过去。成功的响应示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 302 Found</span><br><span class="line">Location: https:&#x2F;&#x2F;client.example.org&#x2F;cb?</span><br><span class="line">  code&#x3D;SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">  &amp;state&#x3D;af0ifjsldkj</span><br></pre></td></tr></table></figure>

<h5 id="6-Authentication-Error-Response"><a href="#6-Authentication-Error-Response" class="headerlink" title="6. Authentication Error Response"></a>6. Authentication Error Response</h5><p>错误响应示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 302 Found</span><br><span class="line">Location: https:&#x2F;&#x2F;client.example.org&#x2F;cb?</span><br><span class="line">  error&#x3D;invalid_request</span><br><span class="line">  &amp;error_description&#x3D;</span><br><span class="line">    Unsupported%20response_type%20value</span><br><span class="line">  &amp;state&#x3D;af0ifjsldkj</span><br></pre></td></tr></table></figure>

<h4 id="Token-Endpoint"><a href="#Token-Endpoint" class="headerlink" title="Token Endpoint"></a>Token Endpoint</h4><h5 id="1-Token-Request"><a href="#1-Token-Request" class="headerlink" title="1. Token Request"></a>1. Token Request</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;token HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"></span><br><span class="line">grant_type&#x3D;authorization_code&amp;code&#x3D;SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">  &amp;redirect_uri&#x3D;https%3A%2F%2Fclient.example.org%2Fcb</span><br></pre></td></tr></table></figure>

<h5 id="3-Successful-Token-Response"><a href="#3-Successful-Token-Response" class="headerlink" title="3. Successful Token Response"></a>3. Successful Token Response</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> &quot;access_token&quot;: &quot;SlAV32hkKG&quot;,</span><br><span class="line"> &quot;token_type&quot;: &quot;Bearer&quot;,</span><br><span class="line"> &quot;refresh_token&quot;: &quot;8xLOxBtZp8&quot;,</span><br><span class="line"> &quot;expires_in&quot;: 3600,</span><br><span class="line"> &quot;id_token&quot;: &quot;eyJhbGciOiJSUzI1NiIsImtpZCI6IjFlOWdkazcifQ.ewogImlzc</span><br><span class="line">   yI6ICJodHRwOi8vc2VydmVyLmV4YW1wbGUuY29tIiwKICJzdWIiOiAiMjQ4Mjg5</span><br><span class="line">   NzYxMDAxIiwKICJhdWQiOiAiczZCaGRSa3F0MyIsCiAibm9uY2UiOiAibi0wUzZ</span><br><span class="line">   fV3pBMk1qIiwKICJleHAiOiAxMzExMjgxOTcwLAogImlhdCI6IDEzMTEyODA5Nz</span><br><span class="line">   AKfQ.ggW8hZ1EuVLuxNuuIJKX_V8a_OMXzR0EHR9R6jgdqrOOF4daGU96Sr_P6q</span><br><span class="line">   Jp6IcmD3HP99Obi1PRs-cwh3LO-p146waJ8IhehcwL7F09JdijmBqkvPeB2T9CJ</span><br><span class="line">   NqeGpe-gccMg4vfKjkM8FcGvnzZUN4_KSP0aAp1tOJ1zZwgjxqGByKHiOtX7Tpd</span><br><span class="line">   QyHE5lcMiKPXfEIQILVq0pc_E2DzL7emopWoaoZTF_m0_N0YzFC6g6EJbOEoRoS</span><br><span class="line">   K5hoDalrcvRYLSrQAZZKflyuVCyixEoV9GfNQC3_osjzw2PAithfubEEBLuVVk4</span><br><span class="line">   XUVrWOLrLl0nx7RkKU8NXNHq-rvKMzqg&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-Token-Error-Response"><a href="#4-Token-Error-Response" class="headerlink" title="4. Token Error Response"></a>4. Token Error Response</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 400 Bad Request</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> &quot;error&quot;: &quot;invalid_request&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="隐式流认证"><a href="#隐式流认证" class="headerlink" title="隐式流认证"></a>隐式流认证</h3><p>使用隐式流（Implicit Flow）来进行认证时，所有的token都由Authorization Endpoint来发放，Token Endpoint不被使用了。</p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>Client准备包含所需请求参数的Authentication Request。</li>
<li>Client发送request到Authorization Server。</li>
<li>Authorization Server认证End-User。</li>
<li>Authorization Server获得EU的同意/授权。</li>
<li>Authorization Server sends the End-User back to the Client with an <code>ID Token</code> and, if requested, an <code>Access Token</code>.</li>
<li>Client验证ID Token并检索用户的End-User’s Subject Identifier。</li>
</ol>
<p><strong>注意</strong>：</p>
<ul>
<li>Implicit Flow中没有Authorization Code Flow的6、7步。</li>
<li>Implicit Flow在5步中直接返回ID Token，而Authorization Code Flow是根据返回的Authorization Code到Token Endpoint去获得ID Token。</li>
</ul>
<h4 id="Authorization-Endpoint-1"><a href="#Authorization-Endpoint-1" class="headerlink" title="Authorization Endpoint"></a>Authorization Endpoint</h4><h5 id="1-Authentication-Request-1"><a href="#1-Authentication-Request-1" class="headerlink" title="1. Authentication Request"></a>1. Authentication Request</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;authorize?</span><br><span class="line">  response_type&#x3D;id_token%20token</span><br><span class="line">  &amp;client_id&#x3D;s6BhdRkqt3</span><br><span class="line">  &amp;redirect_uri&#x3D;https%3A%2F%2Fclient.example.org%2Fcb</span><br><span class="line">  &amp;scope&#x3D;openid%20profile</span><br><span class="line">  &amp;state&#x3D;af0ifjsldkj</span><br><span class="line">  &amp;nonce&#x3D;n-0S6_WzA2Mj HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure>

<h5 id="5-Successful-Authentication-Response-1"><a href="#5-Successful-Authentication-Response-1" class="headerlink" title="5. Successful Authentication Response"></a>5. Successful Authentication Response</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 302 Found</span><br><span class="line">Location: https:&#x2F;&#x2F;client.example.org&#x2F;cb#</span><br><span class="line">  access_token&#x3D;SlAV32hkKG</span><br><span class="line">  &amp;token_type&#x3D;bearer</span><br><span class="line">  &amp;id_token&#x3D;eyJ0 ... NiJ9.eyJ1c ... I6IjIifX0.DeWt4Qu ... ZXso</span><br><span class="line">  &amp;expires_in&#x3D;3600</span><br><span class="line">  &amp;state&#x3D;af0ifjsldkj</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><p><a href="https://openid.net/connect/" target="_blank" rel="noopener">Welcome to OpenID Connect</a></p>
</li>
<li><p><a href="https://openid.net/specs/openid-connect-core-1_0.html" target="_blank" rel="noopener"><strong>OpenID Connect Core 1.0</strong></a></p>
</li>
<li><p><a href="https://openid.net/connect/faq/" target="_blank" rel="noopener">OpenID Connect FAQ and Q&amp;As</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/linianhui/p/openid-connect-core.html" target="_blank" rel="noopener">OIDC（OpenId Connect）身份认证</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/be7cc032a4e9" target="_blank" rel="noopener">OpenID Connect 协议入门指南</a></p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/11/HTTPS%E8%AF%A6%E8%A7%A3%EF%BC%9ATLS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wysec">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/11/HTTPS%E8%AF%A6%E8%A7%A3%EF%BC%9ATLS/" class="post-title-link" itemprop="url">HTTPS详解：TLS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-11 14:39:49" itemprop="dateCreated datePublished" datetime="2020-04-11T14:39:49+08:00">2020-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-19 13:33:35" itemprop="dateModified" datetime="2020-04-19T13:33:35+08:00">2020-04-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h2><p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<p><strong>这里有两个问题</strong></p>
<ol>
<li>如何保证公钥不被篡改？</li>
</ol>
<blockquote>
<p>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p>
</blockquote>
<ol start="2">
<li>公钥加密计算量太大，如何减少耗用的时间？</li>
</ol>
<blockquote>
<p>解决方法：每一次会话（session），客户端和服务器端都生成一个”会话密钥”（session key），用它来加密信息。由于”会话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”会话密钥”本身，这样就减少了加密运算的消耗时间。</p>
</blockquote>
<p>因此，SSL/TLS协议的基本过程是这样的：</p>
<blockquote>
<ol>
<li>客户端向服务器端索要并验证公钥</li>
<li>双方协商并生成”会话密钥”</li>
<li>双方采用”会话密钥”进行加密通信</li>
</ol>
</blockquote>
<p>上面过程的前两步，又称为”握手阶段”（handshake）。</p>
<h2 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h2><p><img src="https://www.ruanyifeng.com/blogimg/asset/201402/bg2014020502.png" alt=""></p>
<p>“握手阶段”涉及四次通信，但需要注意的是，<strong>“握手阶段”的所有通信都是明文的</strong>。</p>
<h3 id="客户端发出请求（ClientHello）"><a href="#客户端发出请求（ClientHello）" class="headerlink" title="客户端发出请求（ClientHello）"></a>客户端发出请求（ClientHello）</h3><p>客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。在这一步，客户端主要向服务器提供以下信息。</p>
<blockquote>
<ol>
<li>支持的协议版本，比如TLS 1.2</li>
<li>一个客户端生成的随机数，稍后用于生成”会话密钥”</li>
<li>支持的加密套件候选列表，比如RSA公钥加密</li>
<li>支持的压缩方法</li>
</ol>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/128529-0bcae5de99b7d6e7.jpg" alt=""></p>
<p>这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。</p>
<p>在2006年，TLS协议加入了一个<a href="http://tools.ietf.org/html/rfc4366" target="_blank" rel="noopener">Server Name Indication</a>扩展，允许客户端向服务器提供它所请求的域名。</p>
<h3 id="服务器回应（SeverHello）"><a href="#服务器回应（SeverHello）" class="headerlink" title="服务器回应（SeverHello）"></a>服务器回应（SeverHello）</h3><p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。</p>
<p>从Server Hello到Server Done，有些服务端的实现是每条单独发送，有服务端实现是合并到一起发送。Sever Hello和Server Done都是只有头没有内容的数据。</p>
<p>服务器的回应包含以下内容。</p>
<blockquote>
<ol>
<li>确认使用的加密通信协议版本，比如TLS1.2。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信</li>
<li>一个服务器生成的随机数，稍后用于生成”会话密钥”</li>
<li>确认使用的加密套件，比如RSA公钥加密</li>
<li>服务器证书</li>
</ol>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/128529-aab67532c3b39353.jpg" alt=""></p>
<h4 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h4><p>服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/128529-86995b047bdca4fb.jpg" alt=""></p>
<h4 id="Server-Key-Exchange"><a href="#Server-Key-Exchange" class="headerlink" title="Server Key Exchange"></a>Server Key Exchange</h4><p>在Diffie-Hellman中，客户端无法自行计算premaster。这需要双方一起参与进行计算，因此客户端需要从服务器获取DH公钥。 在ephemeral DH/EDH中，该公钥不在证书中。因此服务器必须在单独的消息中向客户端发送其临时DH公钥，以便客户端可以计算premaster（双方都需要知道premaster，因为这是他们得出主密钥的方式）。这时就要求客户端发送一个 Server Key Exchange。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/128529-d490081356459e7d.jpg" alt=""></p>
<h4 id="Cerficate-Request"><a href="#Cerficate-Request" class="headerlink" title="Cerficate Request"></a>Cerficate Request</h4><p>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求 Cerficate Request ，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p>
<h4 id="Server-Hello-Done"><a href="#Server-Hello-Done" class="headerlink" title="Server Hello Done"></a>Server Hello Done</h4><p>通知客户端 Server Hello 过程结束。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/128529-f556b00b34e1752b.jpg" alt=""></p>
<h3 id="客户端回应（Certificate-Verify）"><a href="#客户端回应（Certificate-Verify）" class="headerlink" title="客户端回应（Certificate Verify）"></a>客户端回应（Certificate Verify）</h3><p>客户端收到服务器回应以后，首先验证服务器证书Certificate Verify，这些证书通常基于X.509。<u>如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期</u>，就会向访问者显示一个警告，由其选择是否还要继续通信。</p>
<p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p>
<blockquote>
<ol>
<li>一个随机数。该随机数用服务器公钥加密生成Pre-Master Key   //根据服务端公钥生成随机数！</li>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送</li>
<li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验</li>
</ol>
</blockquote>
<h4 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h4><p>上面的随机数，是整个握手阶段出现的第三个随机数，它是客户端使用一些加密算法(例如RSA, Diffie-Hellman)产生一个48个字节的key，这个key叫 <code>pre-master secret</code>，也被称作 <code>pre-master key</code>。服务端用私钥解密这个PreMaster Key得到客户端发送的随机数。至此客户端和服务器就同时有了三个随机数，接着双方就用事先商定的算法各自生成本次会话所用的”会话密钥”。</p>
<p><em>为什么一定要用三个随机数来生成”会话密钥”呢？</em></p>
<blockquote>
<p>不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</p>
<p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p>
<p>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅使用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了。</p>
</blockquote>
<p>客户端将Pre-Master Key传给服务端的过程如下：<br><img src="https://upload-images.jianshu.io/upload_images/128529-8644f5444f48f969.jpg" alt=""></p>
<h4 id="Change-Cipher-Spec-Client"><a href="#Change-Cipher-Spec-Client" class="headerlink" title="Change Cipher Spec(Client)"></a>Change Cipher Spec(Client)</h4><p>ChangeCipherSpec是一个独立的协议，体现在数据包中就是一个字节的数据，用于告知服务端，客户端已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件加密数据并传输了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/128529-4e85e83831670580.jpg" alt=""></p>
<h4 id="Encrypted-Handshake-Message-Client"><a href="#Encrypted-Handshake-Message-Client" class="headerlink" title="Encrypted Handshake Message(Client)"></a>Encrypted Handshake Message(Client)</h4><p>然后，客户端会使用之前协商好的加密套件和Session Secret加密前面的握手消息生成的摘要数据，并传送给服务端，此数据是为了在正式传输应用数据之前对刚刚握手建立起来的加解密通道进行验证。服务端接收后会用会话密钥解密，能解出来说明前面协商出来的密钥是一致的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/128529-936e08831386ec26.jpg" alt=""></p>
<p>～此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息Client Key Exchange。～</p>
<h3 id="服务器的最后回应（Server-Finish）"><a href="#服务器的最后回应（Server-Finish）" class="headerlink" title="服务器的最后回应（Server Finish）"></a>服务器的最后回应（Server Finish）</h3><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p>
<blockquote>
<ol>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>
<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</li>
</ol>
</blockquote>
<h4 id="Change-Cipher-Spec-Server"><a href="#Change-Cipher-Spec-Server" class="headerlink" title="Change Cipher Spec(Server)"></a>Change Cipher Spec(Server)</h4><p>一切准备好之后，会给客户端发送一个 ChangeCipherSpec，告知客户端已经切换到协商过的加密套件状态，准备使用加密套件和 Session Secret加密数据了。</p>
<h4 id="Encrypted-Handshake-Message-Server"><a href="#Encrypted-Handshake-Message-Server" class="headerlink" title="Encrypted Handshake Message(Server)"></a>Encrypted Handshake Message(Server)</h4><p>服务端也会使用Session Secret加密握手过程的消息生成的摘要消息，并发送给客户端，以验证之前通过握手建立起来的加解密通道是否成功。这是服务端发出的第一条加密消息。客户端接收后会用密钥解密，能解出来说明协商的密钥是一致的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/128529-98cd8557d2818a3a.jpg" alt=""></p>
<p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p>
<h2 id="双向证书验证"><a href="#双向证书验证" class="headerlink" title="双向证书验证"></a>双向证书验证</h2><p>下图是双向证书验证的过程。<br><img src="https://upload.wikimedia.org/wikipedia/commons/a/ae/SSL_handshake_with_two_way_authentication_with_certificates.svg" alt=""></p>
<h2 id="密钥协商和加密算法"><a href="#密钥协商和加密算法" class="headerlink" title="密钥协商和加密算法"></a>密钥协商和加密算法</h2><p>在客户端和服务器开始交换TLS所保护的加密信息之前，他们必须安全地交换或协定加密密钥和加密数据时要使用的密码。<u>用于<strong>密钥交换</strong>的方法包括</u>：使用RSA算法生成公钥和私钥（在TLS 握手协议中被称为<code>TLS_RSA</code>），Diffie-Hellman（<code>TLS_DH</code>），ephemeral Diffie-Hellman（<code>TLS_DHE</code>），椭圆曲线迪菲-赫尔曼（<code>TLS_ECDH</code>），ephemeral elliptic-curve Diffie-Hellman（<code>TLS_ECDHE</code>），anonymous Diffie-Hellman（<code>TLS_DH_anon</code>），预共享密钥/pre-shared key（<code>TLS_PSK</code>）和 Secure Remote Password（<code>TLS_SRP</code>）。</p>
<p>TLS_DH_anon和TLS_ECDH_anon的密钥协商协议不能验证服务器或用户，因为易受中间人攻击因此很少使用。只有<code>TLS_DHE</code>和<code>TLS_ECDHE</code>提供<strong>前向保密</strong>能力。</p>
<h3 id="基于-RSA-的密钥协商"><a href="#基于-RSA-的密钥协商" class="headerlink" title="基于 RSA 的密钥协商"></a>基于 RSA 的密钥协商</h3><p>RSA密钥交换中，RSA起的作用是key transmission，也就是说，用于产生session key的“种子”是由客户端决定，用服务器的公钥加密并再次传输到服务器端。（TLS Record Layer: 用密钥k进行加密））</p>
<p>协商的过程大致如下：</p>
<ol>
<li>客户端连上服务端</li>
<li>服务端发送其证书给客户端</li>
<li>客户端验证该证书的有效性</li>
<li>客户端从证书中取出公钥</li>
<li>客户端生成一个随机密钥 k，并用这个公钥加密得到 k’</li>
<li>客户端把 k’ 发送给服务端</li>
<li>服务端收到 k’ 后用自己的私钥解密得到 k</li>
<li>此时双方都得到了密钥 k，协商完成。</li>
</ol>
<p>为了防止RSA密钥协商时的假冒身份，就需要RSA结合数字证书一起使用。</p>
<p>基于RSA的密钥协商的过程是早期的SSLv2使用的唯一种密钥协商机制。</p>
<h3 id="基于-DH-的密钥协商"><a href="#基于-DH-的密钥协商" class="headerlink" title="基于 DH 的密钥协商"></a>基于 DH 的密钥协商</h3><p>Diffie–Hellman（DH）密钥交换中，DH起的作用是key exchange，也就是说，用于产生session key的“种子”，是客户端和服务器都参与了的。这是因为DH可以在通讯双方在完全没有对方任何预先信息的条件下通过不安全信道创建一个双方共享的私有密钥。</p>
<p>协商的过程大致如下：</p>
<ol>
<li>客户端先连上服务端</li>
<li>服务端生成一个随机数 s 作为自己的私钥，然后根据算法参数计算出公钥 S（算法参数通常是固定的）</li>
<li>服务端使用某种签名算法（RSA、DSA、ECDSA）把『算法参数（模数 p，基数 g）和服务端公钥 S』作为一个整体进行签名</li>
<li>服务端把『算法参数（模数 p，基数 g）、服务端公钥S、签名』发送给客户端</li>
<li>客户端收到后验证签名是否有效</li>
<li>客户端生成一个随机数 c 作为自己的私钥，然后根据算法参数计算出公钥 C</li>
<li>客户端把 C 发送给服务端</li>
<li>客户端和服务端（根据上述 DH 算法）各自计算出 k 作为会话密钥</li>
</ol>
<p>由于DH 算法本身有不支持认证的缺点。就是说：它虽然可以对抗“偷窥”，却无法对抗“篡改”，自然也就无法对抗“中间人攻击/MITM”。因此DH 需要与其它签名算法（如 RSA、DSA、ECDSA）配合，靠签名算法帮忙来进行身份认证。当 DH 与 RSA 配合使用，称之为<code>DH-RSA</code>，与 DSA 配合则称为<code>DH-DSA</code>，以此类推。如果 DH没有配合某种签名算法，则称为“DH-ANON”，此时它会遭遇“中间人攻击/MITM”。。</p>
<p>DH 算法有一个变种，称之为 ECDH（全称是“Elliptic Curve Diffie-Hellman”）。它与 DH 类似，差别在于：DH 依赖的是求解“离散对数问题”的困难；ECDH 依赖的是求解“椭圆曲线离散对数问题”的困难。另外，ECDH 跟 DH 一样，也是“无认证”的，同样需要跟其它签名算法配合使用。</p>
<p>由于DH 和 ECDH的密钥是持久的（静态的）。就是说通讯双方生成各自的密钥之后，就长时间用下去。但是这样存在安全隐患，就是无法做到<a href="https://en.wikipedia.org/wiki/Forward_secrecy" target="_blank" rel="noopener">前向保密</a>。为了达到“前向保密”，就是每次会话都要重新协商一次密钥（都随机生成私钥），用完后就丢弃掉。就出现了针对上述两个算法的改良版本DHE 和 ECDHE。</p>
<h3 id="基于-PSK-的密钥协商"><a href="#基于-PSK-的密钥协商" class="headerlink" title="基于 PSK 的密钥协商"></a>基于 PSK 的密钥协商</h3><p>PSK （Pre-Shared Key），预共享密钥。就是在通信前就预先让通信双方共享一些密钥（通常是对称加密的密钥）。这样的好处是：不依赖公钥体系；不涉及非对称加密。</p>
<p>由于通信双方已经预先配置了若干共享的密码。为了标识多个密钥，给每一个密钥定义一个唯一的 ID。在协商时，客户端把自己选好的密钥的 ID 告诉服务端，服务端在自己的密钥池子中找到这个 ID，就用对应的密钥与客户端通讯；否则就报错并中断连接。</p>
<p>PSK 可以单独使用，也可以搭配签名算法一起使用。</p>
<ul>
<li>单独使用：协议初始化/握手阶段的末尾，双方都会向对方发送一段“验证性的密文”，这段密文用各自的会话密钥进行<strong>对称加密</strong>，如果双方的会话密钥不一致，这一步就会失败，进而导致握手失败，连接终止。</li>
<li>搭配签名算法：如果攻击者篡改了协商过程中传送的密钥 ID，验证签名会失败.    //PSK-RSA</li>
</ul>
<blockquote>
<p>由于 PSK 与 RSA 具有某种相似性，既可以“密钥协商”，也可以“身份认证”。因此 PSK 也可以跟 DH（及其变种）进行组合。例如：DHE-PSK、ECDHE-PSK</p>
</blockquote>
<h3 id="基于-SRP-的密钥协商"><a href="#基于-SRP-的密钥协商" class="headerlink" title="基于 SRP 的密钥协商"></a>基于 SRP 的密钥协商</h3><p>SRP，Secure Remote Password protocol。它和PSK类似，只不过 client/server 双方共享的是比较人性化的密码（password）而不是密钥（key）。该算法采用了一些机制（盐/salt、随机数）来防范“嗅探/sniffer”或“字典猜解攻击”或“重放攻击”。</p>
<h3 id="安全的密钥交换协议"><a href="#安全的密钥交换协议" class="headerlink" title="安全的密钥交换协议"></a>安全的密钥交换协议</h3><p>在TLS1.3中推荐使用：</p>
<ul>
<li>DHE-RSA（具有前向安全性）</li>
<li>ECDHE-RSA（具有前向安全性）</li>
<li>ECDHE-ECDSA（具有前向安全性）</li>
</ul>
<h3 id="安全的加密"><a href="#安全的加密" class="headerlink" title="安全的加密"></a>安全的加密</h3><p>在TLS1.3中推荐使用：</p>
<ul>
<li>AES GCM（块密码）</li>
<li>AES CCM（块密码）</li>
<li>ChaCha20-Poly1305（流密码）</li>
</ul>
<h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h3><p>在TLS1.3中推荐使用：</p>
<ul>
<li>AEAD</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank" rel="noopener">HTTPS</a></p>
<p><a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="noopener">Transport Layer Security</a></p>
<p><a href="https://program-think.blogspot.com/2016/09/https-ssl-tls-3.html" target="_blank" rel="noopener">扫盲 HTTPS 和 SSL/TLS 协议3：密钥交换（密钥协商）算法及其原理</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></p>
<p><a href="http://seanlook.com/2015/01/07/tls-ssl/" target="_blank" rel="noopener">SSL/TLS原理详解</a></p>
<p><a href="http://insights.thoughtworkers.org/cipher-behind-https/" target="_blank" rel="noopener">http://insights.thoughtworkers.org/cipher-behind-https/</a></p>
<p><a href="http://honglu.me/2016/01/13/HTTPS%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">http://honglu.me/2016/01/13/HTTPS%E8%AF%A6%E8%A7%A3/</a></p>
<p><a href="https://www.jianshu.com/p/7158568e4867" target="_blank" rel="noopener">SSL/TLS 握手过程详解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wysec</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wysec</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
